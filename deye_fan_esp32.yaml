esphome:
  name: deye-fan-esp32

esp32:
  board: lolin_d32_pro
  framework:
    type: esp-idf
  # Board customization options
  cpu_frequency: 240MHz  # Options: 80MHz, 160MHz, 240MHz
  flash_size: 4MB        # Flash memory size

# Enable logging with reduced verbosity for better performance
logger:
  level: INFO
  logs:
    esp32.wifi: WARN
    esp32.wifi_component: WARN

# Enable Home Assistant API
api:
  password: !secret api_password

# Web server for configuration
web_server:
  port: 80
  include_internal: true
  # Reduce connection timeout to prevent error 23
  version: 1.0

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  id: deyefan_wifi
  fast_connect: true
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  # WiFi stability settings
  power_save_mode: none
  reboot_timeout: 15min
  # Additional stability settings
  output_power: 20dBm

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: !secret fallback_ap_ssid
    password: !secret fallback_ap_password

captive_portal:

time:
  - platform: sntp
    id: sntp_time
    timezone: Pacific/Auckland
    servers:
     - 0.nz.pool.ntp.org
     - 1.nz.pool.ntp.org
     - 2.nz.pool.ntp.org

# Internet connectivity will be determined by NTP sync status

spi:
  clk_pin: 18
  mosi_pin: 23

i2c:
  sda: 21
  scl: 22
  scan: true

font:
  - file: "OpenSans-Regular.ttf"
    id: small
    size: 10
  - file: "OpenSans-Regular.ttf"
    id: large
    size: 24
  - file: "fa-solid-900.ttf"
    id: fa_icons
    size: 20
    glyphs:
      - "\uf1eb"  # wifi
      - "\uf0ac"  # globe
      - "\uf017"  # clock
      - "\uf021"  # sync
      - "\uf2c8"  # thermometer
      - "\uf071"  # exclamation

# Font Awesome icons are used for status indicators

text_sensor:
  - platform: wifi_info
    ip_address:
      name: "WiFi IP"
      id: wifi_ip

sensor:
  - platform: sht3xd
    temperature:
      name: "Deye Temperature"
      id: temperature_sensor
    humidity:
      name: "Deye Humidity"
      id: humidity_sensor
    address: 0x45
    update_interval: 10s

binary_sensor:
  - platform: template
    name: "Internet Connectivity"
    id: internet_connectivity
    device_class: connectivity
    lambda: |-
      return id(sntp_time).now().is_valid();
  - platform: template
    name: "Relay State"
    id: relay_state_sensor
    device_class: heat
    lambda: |-
      return id(relay_state);

number:
  - platform: template
    name: "Temperature Limit"
    id: temperature_limit_number
    min_value: 0.0
    max_value: 50.0
    step: 0.1
    mode: box
    unit_of_measurement: "°C"
    restore_value: true
    initial_value: 25.0
    set_action:
      - globals.set:
          id: temperature_limit
          value: !lambda |-
            return x;

# Global variables for display throttling and relay control
globals:
  - id: last_display_update
    type: int
    restore_value: false
    initial_value: '0'
  - id: temperature_limit
    type: float
    restore_value: true
    initial_value: '25.0'
  - id: relay_state
    type: bool
    restore_value: false
    initial_value: 'false'

# Display updates and temperature-based relay control
interval:
  - interval: 2s
    then:
      - globals.set:
          id: last_display_update
          value: '1'
  - interval: 5s
    then:
      # Temperature-based relay control
      - if:
          condition:
            and:
              - lambda: |-
                  return id(temperature_sensor).has_state();
              - lambda: |-
                  return id(temperature_sensor).state > id(temperature_limit);
          then:
            - globals.set:
                id: relay_state
                value: 'true'
      - if:
          condition:
            and:
              - lambda: |-
                  return id(temperature_sensor).has_state();
              - lambda: |-
                  return id(temperature_sensor).state <= id(temperature_limit);
          then:
            - globals.set:
                id: relay_state
                value: 'false'

display:
  - platform: st7735
    col_start: 0
    row_start: 0
    device_height: 128
    device_width: 128
    model: "INITR_GREENTAB"
    cs_pin: 14
    dc_pin: 27
    # led_pin: 32
    reset_pin: 33
    id: display_main
    update_interval: 3s
    lambda: |-
      // Only update display when flag is set - minimal processing in lambda
      if (id(last_display_update) == 0) {
        return;
      }
      
      // Reset the update flag
      id(last_display_update) = 0;
      
      // Icon bar at the top (y=0 to y=20) - evenly spaced across 128px width
      // WiFi status icon (left)
      if (id(deyefan_wifi).is_connected()) {
        it.printf(8, 2, id(fa_icons), TextAlign::TOP_LEFT, "\uf1eb"); // wifi icon
      }
      
      // Internet status icon (center-left)
      if (id(internet_connectivity).state) {
        it.printf(40, 2, id(fa_icons), TextAlign::TOP_LEFT, "\uf0ac"); // globe icon
      }
      
      // NTP status icon (center-right)
      if (id(sntp_time).now().is_valid()) {
        it.printf(72, 2, id(fa_icons), TextAlign::TOP_LEFT, "\uf017"); // clock icon
      }
      
      // Sensor status icon (right)
      if (id(temperature_sensor).has_state()) {
        it.printf(104, 2, id(fa_icons), TextAlign::TOP_LEFT, "\uf2c8"); // thermometer icon
      }

      // Main content area - Temperature as center focus
      // Print temperature (centered, large)
      if (id(temperature_sensor).has_state()) {
        it.printf(64, 50, id(large), TextAlign::CENTER, "%.1f°C", id(temperature_sensor).state);
      }

      // Print temperature limit and relay state (below temperature)
      it.printf(64, 80, id(small), TextAlign::CENTER, "Limit: %.1f°C", id(temperature_limit));
      
      // Print relay state
      if (id(relay_state)) {
        it.printf(64, 95, id(small), TextAlign::CENTER, "RELAY ON");
      } else {
        it.printf(64, 95, id(small), TextAlign::CENTER, "Relay Off");
      }

      // Bottom status bar (y=108 to y=128)
      // Print time (bottom left)
      if (id(sntp_time).now().is_valid()) {
        it.strftime(0, 128, id(small), TextAlign::BOTTOM_LEFT, "%H:%M", id(sntp_time).now());
      }

      // Print WiFi IP address (bottom right)
      if (id(wifi_ip).has_state()) {
        it.printf(127, 128, id(small), TextAlign::BOTTOM_RIGHT, "IP: %s", id(wifi_ip).state.c_str());
      }

